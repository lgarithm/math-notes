\documentclass{article}
\usepackage{amssymb}
\usepackage{enumerate}
\def\abs#1{\left| {#1} \right|}
\def\im{\mathop{\mathrm{im}}}
\def\supp{\mathop{\mathrm{supp}}}
\def\true{\mathop{\mathrm{true}}}
\def\false{\mathop{\mathrm{false}}}
\def\Reg{\mathop{\mathrm{Reg}}}
\title{Topics on the Basis of Computer Science}
\author{Lgarithm\\ \mbox{lgarithm@gmail.com}\\ Department of Computer Science, Sichuan University}
\begin{document}
\maketitle

\paragraph{Abstract}
This article gives a brief summary of the basic topics of computer science,
including formal language, automata, computation theory and mathematical logic.

\paragraph{Forword}
The history of modern compute machine is very short, but develop quickly.
One reason is largely due to commercialize of personal computer.
But there is a mathematical background deeply behind the mathine,which develops on its own way, much more early before the born of modern computer.
In fact, the Turing theory can be treated pure mathematically.

So I give a glipse of some aspects of the topics on the basis of computer science.

\newpage
\tableofcontents
\newpage

\paragraph{Preliminary}
% Suppose the reader knows the concepts of set theory and abstract algebra.
% Set, semigroup, monoid will be frequently used.
Let $A, B$ be sets, a binary relation on $A$ and $B$ is a subset of $A \times B$.$A \subseteq B$ if and only $A \in \mathcal{P}(B)$.
\section{Formal Language}
\subsection{Alphabet and Word}An alphabet is a set, usually finite and denoted by Greek capital letter $\Sigma$.
A word on $\Sigma$ is a finite sequence whose elements are from $\Sigma$.
The set of all words on $\Sigma$ is denoted by $\Sigma^+$.
We introduce the empty word $\epsilon$, and denote $\Sigma^+ \cup \{\epsilon\}$ by $\Sigma^\ast$
\footnote{With word concatenation, $\Sigma^\ast$ forms a monoid, known as the free monoid on
$\Sigma$.}.Let $x, y, z, w \in \Sigma^\ast$ be words, if $w = xyz$, we say $x$ is a prefix of $w$,
$z$ is a suffix of $w$ and $y$ is a subword of $w$.
The support of a word $w \in \Sigma^\ast$, is a subset of $\Sigma$ whose elements occured in $w$,
denoted by $\supp(w)$.
The support of a language $L$ is the union of the support of all its members, denoted by $\supp(L)$.

By a language $L$ over $\Sigma$, we mean a subset of $\Sigma^\ast$.
\footnote{In some other books, a language over $\Sigma$ only means those can be generated by a grammar.}
Let $\mathcal{L} = \mathcal{L}(\Sigma) = \mathcal{P}(\Sigma^\ast)$, the class of all languages,
A subset of $\mathcal{L}$ is called a class of languages, which is a set of languages.
Note that $\Sigma^\ast$ is countable while $\mathcal{L}$ is uncountable.
Some classes of languages are of special intrest, they are regular language,
context free language, recursive language and recursively enumerable language.
We will talk some of them next.

\subsection{Regular Language}
The regular languages is a class of languages which are of great important.
We denote the class of regular languages by $\mathcal{R}$.
$\mathcal{R}$ can be defined by induciton.
First we define some operations on $\mathcal{L}$.
The union of two languages $L_1$ and $L_2$ is just the set union of $L_1$ and $L_2$.
The concatenation of two languages $L_1$ and $L_2$ is
$L_1 \circ L_2 = \{s\circ t \vert s \in L_1, t \in L_2\}$.
The Kleene star of $L$ is
$L^\ast = \{s_1 \circ s_2\circ \dots \circ s_k \vert k \in \mathbb{N}, s_i \in L\}$
\footnote{When k=0, the result is the empty word.}.
These three operations are called regular operation,
they can be viewed as functions $\cup, \circ : \mathcal{L}^2 \to \mathcal{L}$
and $\ast : \mathcal{L} \to \mathcal{L}$.Now $\mathcal{R}$ can be defined as the minimum fix point which is closed under regular operations,
such that $\{\epsilon\}$, $\emptyset$ and $\{a\}(a \in \Sigma)$ are members of $\mathcal{R}$.

\subsection{Regular Expression}
The union, concatenation and Kleene star are called regular operations.
Just like $+, \ast$ in a ring, $\cup, \circ, \ast$ plays the same role in $\mathcal{R}$.
So now we will define a analog of polynomial in $\mathcal{R}$, that is regular expression.We denote the set of all regular expressions over $\Sigma$ by $\Reg[\Sigma]$.
Then $\Reg[\Sigma]$ will be defined as a formal language over $\Sigma \cup S$, where $S = \{\circ, \cup, \ast, (, ), \epsilon, \emptyset\}$
is a finite set of symbols which may occur in a regular expression.
The definition of regular expression is recursive:
\begin{enumerate}[i).]
\item $\Sigma \cup \{\epsilon, \emptyset\} \subseteq \Reg[\Sigma]$;
\item if $r, g \in \Reg[\Sigma] \backslash \{\epsilon, \emptyset\}$,
so is $(r \circ g)$, $(r \cup g)$, $(r^\ast)$.
\end{enumerate}

We can see each regular expression $r$ represents a subset of $\Sigma^\ast$,
more specificly, a regular language.
In fact, there is a natural map $\pi : \Reg[\Sigma] \to \Sigma^\ast$, defined by induction.
$\pi(\epsilon) = \epsilon$, $\pi(\emptyset) = \emptyset$;
if $\sigma \in \Sigma$, $\pi(\sigma) = \sigma$;
if $r = (f \circ g)$, $\pi(r) = \pi(f) \circ \pi(g)$;
if $r = (f \cup g)$, $\pi(r) = \pi(f) \cup \pi(g)$;
if $r = (f^\ast)$, $\pi(r) = \pi(f)^\ast$.
Different regular expression may represent the same set.

We say a word $s \in \Sigma^\ast$ is matched by $R \in \Reg[\Sigma]$,
if $s$ is in the set represented by $R$, that is $s \in \pi(R)$.

Later we will see $\Reg[\Sigma]$ is a context free language over $\Sigma \cup S$.

\subsection{Some Properties of Regular Expression}
Let $r \in \Reg[\Sigma]$ be a regular expression,
$\pi(r) \in \Sigma^\ast$ be the regular language represented by $r$,
then $\supp(\pi(r)) = \supp(r) \cap \Sigma$.

\subsection{Formal Grammar}
A formal grammer is $G = G(V, T, P, S)$, where $V, T, P$ are finite sets and $S \in V$.
$V$ is the set of variables with a special start variable $S$;
$T$ is the set of terminals, which plays the same role as $\Sigma$;
and $P$ a set of production rules. Moreover, $V \cup T = \emptyset$;
The set of production rules $P$ is a binary relation on $(V \cup T)^+$ and $(V \cup T)^\ast$.

Now we are ready describe the language defined by $G$, namely $L(G)$.
First we introduce a binary relation $\to$ on $(V \cup T)^\ast$.
For $A, B \in (V \cup T)^\ast$,
$A \to B$ if and only if exist $u, v, x, y, s, t \in (V \cup T)^\ast$,
such that $A = usv, B = xty$ and $(s, t) \in P$.
Let $\Rightarrow$ be the transitive closure of $\to$,
then define $L(G) = \{w \in T^\ast \mid S \Rightarrow w\}$.

\subsection{Context Free Language}
The class of regular languages $\mathcal{R}$ is a only proper subset of $\mathcal{L}$.So there are languages that not regular, the context language is a wider class of languages,
which containing $\mathcal{R}$ as a proper subset.

A grammer $G(V, T, P, S)$ is context free if $P \subseteq V^+ \times (V \cup T)^\ast$,
and a language $L$ is context free if it is identical to $L(G)$ for some context free grammer $G$.

\subsection{Representation of a Language Class}
Let $\Sigma, \Pi$ be alphabets,
$\mathcal{R} \subseteq \mathcal{L}(\Sigma)$ be class of languages over $\Sigma$,
$R \in \mathcal{L}(\Pi)$ be a language over $\Pi$.
We say $\mathcal{R}$ is represented by $R$, or $R$ represents $\mathcal{R}$,
if there is a map $\pi : R \to \mathcal{L}(\Sigma)$, such that $\im \pi = \mathcal{R}$.
A class of language $\mathcal{R} \subseteq \mathcal{L}(\Sigma)$ is finite representable,
if and only if exist $\Pi$ and $R \in \mathcal{L}(\Pi)$ such that $R$ represents $\mathcal{R}$.

We've already seen an example, that is,
the class of regular languages $\mathcal{R}$ can be represented by a context free language,
namely the regular expressions $\Reg[\Sigma]$.


\section{Automata}
Automata is the abstract model of a computer. It also can be used to describe formal languages.
An automata also can describe an infinite language with only finite data.

\subsection{Finite State Automata}
The determistic finite state Automata, or simply DFA,
provides an approach to describe a regular language, possibly infinite, with finite information.
The information required to describe a DFA are a finite set of states $Q$,
a transition function $\delta : Q \times \Sigma \to Q$,
where $\Sigma$ is the alphabet of the language we want to describe.
Besides, a specific element $q_0 \in Q$, which is the start state,
and a subset $F \subseteq Q$, which is the set of accept state.
We denote such a DFA by $M(Q, \Sigma, \delta, q_0, F)$.

\subsubsection{Language of DFA}
Given a DFA $M(Q, \Sigma, \delta, q_0, F)$, $M$ induce a function
\footnote{In detail, each element of $\Sigma$ can be viewed as a right operator on $Q$,
then for $q \in Q, a \in \Sigma$, $(q, a) \to qa$ is the map $\delta : Q \times \Sigma \to Q$,define $\tilde\delta$ to be the extension of $\delta$ by
$\tilde\delta : Q \times \Sigma^\ast \to Q$.
Let $M$ be the restriction of $\tilde\delta$ on $\{q_0\} \times \Sigma^\ast$, $M : \Sigma^\ast \to Q$.}
$M : \Sigma^\ast \to Q$ as follows:
$$M(x_1x_2\dots x_n) = \cases{q_0 & $n = 0$\cr \delta(M(x_1x_2\dots x_{n-1}), x_n) & $n > 0$}.$$
Let $\chi_F$ be the character function of $F$,
therefore $\chi_L = \chi_F \circ M : \Sigma^\ast \to \{0, 1\}$ is a character function on $\Sigma^\ast$,
now we can define the language of $M$ according to $\chi_L$,
$L(M) = \{s \mid \chi_F \circ M (s) = 1\}$.
The Kleene's theorem says a language is regular if and only if it is identical to $L(M)$ for some DFA $M$.

In the construction, $\Sigma^\ast$ can be viewed a operator monoid on $Q$, whith identity $\epsilon$.
Since $Q$ is finite, the operators on $Q$ is finite, at most $\abs{Q}^{\abs{Q}}$.
But $\Sigma^\ast$ is infinite, then we can define an equivalent relation $\sim$ on $\Sigma^\ast$,
$s \sim t$ if and only if $\tilde\delta(q, s) = \tilde\delta(q, t)$ for all $q \in Q$,
and this equivalent relation has only finite many equivalent classes.

\subsubsection{Graph of a DFA}
Given a DFA, we can draw a directed multi-graph to represent it.
Each state of the automata will be a vertex of the graph,
we draw a circle and write the state name inside it,
and for accept states, we use double border to distingush.

From each state $q$, we will draw $\abs{\Sigma}$ arrows, labeled by $\sigma_1, \dots, \sigma_{\abs{\Sigma}}$,
the $i$-th arrow is point to $\delta(q, \sigma_i)$.
And we will draw an arrow point to $q_0$ to indicate the start state.

Now, there is a one-to-one coressponding from $\Sigma^\ast$ to the paths starts from $q_0$,
$s \in \Sigma^\ast$ is accepted by the automata if and only if the path of $s$ ends in an accept state.

\subsection{Push Down Automata}
Push down automata, or PDA for short, is an evolution of
DFA, it can describe a larger class of language than DFA.

\subsection{Turing Machine}
Turing machine is a DFA with a long tape and a head. The tape is infinite long and has only one end.
The head can read or write information on that tape and move both direction
according to it's transition function.
The formal description of Turing machine is a seven truple
$T(Q, \Sigma, \Gamma, \delta, q_0, q_{accept}, q_{reject})$.
$Q$ is the state set and $\Sigma$ is the alphabet just like the DFA.
$\Gamma$ is the alphabeta whose element can be read from or write to the tape.
$q_{accept} \neq q_{reject}$ are two states where the machine will halt on reach them.
$Q \subset \Gamma$ and there is a special letter $sp \in \Gamma$, $sp \notin Q$.
The transition function $\delta$ is of the form
$$\delta : Q \times \Gamma \to Q \times \Gamma \times \{L, R\}.
$$ Which means if $\delta : (q, \gamma) \to (q_1, \gamma_1, d)$,
then the state change form $q$ to $q_1$,
the letter on tape under the header change from $\gamma$ to $\gamma_1$,
and the header move to its left or right according to $d$.
However, if the header is at the left most of tape and $d = L$, it don't move on that step.

Initially, the state is $q_0$ and the input word is written on the left most of the tape,
the rest of tape are filled with $sp$. Then the machine works according to the transition function.
The output is $accept$ or $reject$. But the machine may run forever and gives no output.
So the Turing machine $T$ induce a partial function $$T : \Sigma^\ast \to \{q_{accept}, q_{reject}\}.$$
If this function is a total function, we call machine $T$ a decider.
The language of $T$ is $L(T) = \{w \vert T(w) = q_{accept}\}$.
\section{Theory of Computation}

\section{Formal Logic}
Formal logic is based on formal language.	More specificly, formal logic uses formal language to present theorems, and prooves.

\subsection{Proper Formula}Proper formula is the most elementsry language of formal logic.
The alphabte of proper formula consist of a set of variables $V$,
a set of operators $\{\land, \lor , \lnot , \rightarrow\}$, and $\{(, )\}$.
The words of proper formula $L_p$\footnote{We use this symbol to denote the
set of all words of proper formula, and this will not be confused with real
analysis in context.}
can be defined as follows: every single variable is a proper formula;
if $a$ and $b$ are proper formulas, $(a \land b), (a \lor b), (a \rightarrow b)$
and $(\lnot a)$ are proper formula.

\subsection{Propositional Logic}
The proper formulas can be used to present a fact which is meaningful,
but we can not do proper induction or prove on it.
To do so, we need extra symbols to form a larger alphabet.

\subsection{Predicate Logic}

\subsection{Model}
In this section, we consider an infinite alphabet $\Sigma$
and the formal language $L_p$ over it.

For each letter in $\Sigma$, we can assign a value, which is
either $\true$ or $\false$ to it. Then each assignment can be
viewed as function $v : \Sigma \to \mathcal{B}$,
where $\mathcal{B} = \{\true, \false\}$. The set of all assignments is $\mathcal{B}^\Sigma$, and can be identical to $\mathcal{P}(\Sigma)$,
we denote it by $\mathcal{V}$.

Then we consider a proper formula $p$ in $L_p$. Given an assignment
$v$ in $\mathcal{B}^\Sigma$, we can figure out the truth of $p$ according $v$,
if we define the following rules inductively.

Show the truth table of all operators.

Therefore, we have $(v, p) \to \mathcal{B}$, $v \in \mathcal{V}, p \in L_p$.
Let $\Pi$ be a set of proper formulas, that is a subset of $L_p$,
define $\mathcal{M}(\Pi)$ to be the subset of $\mathcal{V}$ such that all
elements of $\Pi$ is $\true$ according the assignment of $\mathcal{M}(\Pi)$,
$$\mathcal{M}(\Pi) = \{v \mid (v, p) = \true \forall p \in \Pi\}$$
\end{document}
